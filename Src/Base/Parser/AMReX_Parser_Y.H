#ifndef AMREX_PARSER_Y_H_
#define AMREX_PARSER_Y_H_
#include <AMReX_Config.H>

#include <AMReX_GpuQualifiers.H>
#include <AMReX_GpuPrint.H>
#include <AMReX_Math.H>
#include <AMReX_Print.H>
#include <AMReX_REAL.H>

#include <cstddef>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <set>
#include <string>
#include <type_traits>

void amrex_parsererror (char const *s, ...);

namespace amrex {

enum parser_f_t {
    // functions with one argument
    PARSER_F1_NEG,
    PARSER_F1_INV,
    PARSER_F1_SQRT,
    PARSER_F1_EXP,
    PARSER_F1_LOG,
    PARSER_F1_LOG10,
    PARSER_F1_SIN,
    PARSER_F1_COS,
    PARSER_F1_TAN,
    PARSER_F1_ASIN,
    PARSER_F1_ACOS,
    PARSER_F1_ATAN,
    PARSER_F1_SINH,
    PARSER_F1_COSH,
    PARSER_F1_TANH,
    PARSER_F1_ABS,
    PARSER_F1_FLOOR,
    PARSER_F1_CEIL,
    PARSER_F1_POW_M3,
    PARSER_F1_POW_M2,
    PARSER_F1_POW_P2,
    PARSER_F1_POW_P3,
    PARSER_F1_COMP_ELLINT_1,
    PARSER_F1_COMP_ELLINT_2,
    // functions with two arguments
    PARSER_F2_ADD,
    PARSER_F2_SUB,
    PARSER_F2_MUL,
    PARSER_F2_DIV,
    PARSER_F2_POW,
    PARSER_F2_GT,
    PARSER_F2_LT,
    PARSER_F2_GEQ,
    PARSER_F2_LEQ,
    PARSER_F2_EQ,
    PARSER_F2_NEQ,
    PARSER_F2_AND,
    PARSER_F2_OR,
    PARSER_F2_HEAVISIDE,
    PARSER_F2_JN,
    PARSER_F2_MIN,
    PARSER_F2_MAX,
    PARSER_F2_FMOD,
    // functions with three arguments
    PARSER_IF
};

/*
 * V: double value
 * I: int value
 * P: pointer to number (i.e., symbol)
 * N: node
 */
enum parser_node_t {
    PARSER_NUMBER,
    PARSER_SYMBOL,
    PARSER_ADD,
    PARSER_SUB,
    PARSER_MUL,
    PARSER_DIV,
    PARSER_NEG,
    PARSER_F1,
    PARSER_F2,
    PARSER_F3,
    PARSER_ASSIGN,
    PARSER_LIST,
    PARSER_F1_P,   /* types below are generated by optimization */
    PARSER_F2_NV,
    PARSER_F2_NP,
    PARSER_F2_VN,
    PARSER_F2_PN,
    PARSER_F2_PV,
    PARSER_F2_PP,
    PARSER_F2_VP,
    PARSER_F2_NI,
    PARSER_F2_PI
};

/* In C, the address of the first member of a struct is the same as
 * the address of the struct itself.  Because of this, all struct parser_*
 * pointers can be passed around as struct parser_node pointer and enum
 * parser_node_t type can be safely checked to determine their real type.
 */

struct parser_node {
    enum parser_node_t type;
    enum parser_f_t   ftype;
    struct parser_node* l;
    struct parser_node* r;
    struct parser_node* foo = nullptr; // to extend size
};

struct parser_number {
    enum parser_node_t type;
    double value;
};

struct parser_symbol {
    enum parser_node_t type;
    int ip;
    char* name;
};

struct parser_f1 {  /* Builtin functions with one argument */
    enum parser_node_t  type;
    enum parser_f_t     ftype;
    struct parser_node* l;
};

struct parser_f2 {  /* Builtin functions with two arguments */
    enum parser_node_t  type;
    enum parser_f_t     ftype;
    struct parser_node* l;
    struct parser_node* r;
};

struct parser_f3 { /* Builtin functions with three arguments */
    enum parser_node_t  type;
    enum parser_f_t     ftype;
    struct parser_node* n1;
    struct parser_node* n2;
    struct parser_node* n3;
};

struct parser_assign {
    enum parser_node_t    type;
    struct parser_symbol* s;
    struct parser_node*   v;
};

struct parser_f1_p {
    enum parser_node_t  type;
    enum parser_f_t     ftype;
    struct parser_node* l;
    int ip;
}

struct parser_f2_nv {
    enum parser_node_t  type;
    enum parser_f_t     ftype;
    struct parser_node* l;
    double v;
}

struct parser_f2_np {
    enum parser_node_t  type;
    enum parser_f_t     ftype;
    struct parser_node* l;
    struct parser_node* r;
    int rip;
}

struct parser_f2_vn {
    enum parser_node_t  type;
    enum parser_f_t     ftype;
    struct parser_node* r;
    double v;
}

struct parser_f2_pn {
    enum parser_node_t  type;
    enum parser_f_t     ftype;
    struct parser_node* l;
    struct parser_node* r;
    int lip;
}

struct parser_f2_pv {
    enum parser_node_t  type;
    enum parser_f_t     ftype;
    struct parser_node* l;
    int lip;
    double v;
};

struct parser_f2_pp {
    enum parser_node_t  type;
    enum parser_f_t     ftype;
    struct parser_node* l;
    struct parser_node* r;
    int lip;
    int rip;
};

struct parser_f2_vp {
    enum parser_node_t  type;
    enum parser_f_t     ftype;
    struct parser_node* r;
    double v;
    int rip;
};

struct parser_f2_ni {
    enum parser_node_t  type;
    enum parser_f_t     ftype;
    struct parser_node* l;
    int i;
};

struct parser_f2_pi {
    enum parser_node_t  type;
    enum parser_f_t     ftype;
    struct parser_node* l;
    int lip;
    int i;
};

static_assert(sizeof(parser_f3) <= sizeof(parser_node) &&
              sizeof(parser_f2_pp) <= sizeof(parser_node),
              "amrex parser: sizeof parser_node too small");

/*******************************************************************/

/* These functions are used in bison rules to generate the original AST. */
void parser_defexpr (struct parser_node* body);
struct parser_symbol* parser_makesymbol (char* name);
struct parser_node* parser_newnode (enum parser_node_t type, struct parser_node* l,
                                    struct parser_node* r);
struct parser_node* parser_newnumber (double d);
struct parser_node* parser_newsymbol (struct parser_symbol* sym);
struct parser_node* parser_newf1 (enum parser_f_t ftype, struct parser_node* l);
struct parser_node* parser_newf2 (enum parser_f_t ftype, struct parser_node* l,
                                  struct parser_node* r);
struct parser_node* parser_newf3 (enum parser_f_t ftype, struct parser_node* n1,
                                  struct parser_node* n2, struct parser_node* n3);
struct parser_node* parser_newassign (struct parser_symbol* s, struct parser_node* v);
struct parser_node* parser_newlist (struct parser_node* nl, struct parser_node* nr);

/*******************************************************************/

/* This is our struct for storing AST in a more packed way.  The whole
 * tree is stored in a contiguous chunk of memory starting from void*
 * p_root with a size of sz_mempool.
 */
struct amrex_parser {
    void* p_root;
    void* p_free;
    struct parser_node* ast;
    std::size_t sz_mempool;
};

struct amrex_parser* amrex_parser_new ();
void amrex_parser_delete (struct amrex_parser* parser);

struct amrex_parser* parser_dup (struct amrex_parser* source);
struct parser_node* parser_ast_dup (struct amrex_parser* parser, struct parser_node* node, int move);

void parser_regvar (struct amrex_parser* parser, char const* name, int i);
void parser_setconst (struct amrex_parser* parser, char const* name, double c);
void parser_print (struct amrex_parser* parser);
std::set<std::string> parser_get_symbols (struct amrex_parser* parser);
int parser_depth (struct amrex_parser* parser);

/* We need to walk the tree in these functions */
void parser_ast_optimize (struct parser_node* node);
std::size_t parser_ast_size (struct parser_node* node);
void parser_ast_print (struct parser_node* node, std::string const& space, AllPrint& printer);
void parser_ast_regvar (struct parser_node* node, char const* name, int i);
void parser_ast_setconst (struct parser_node* node, char const* name, double c);
void parser_ast_get_symbols (struct parser_node* node, std::set<std::string>& symbols,
                             std::set<std::string>& local_symbols);
int parser_ast_depth (struct parser_node* node);

/*******************************************************************/

template <typename T>
AMREX_GPU_HOST_DEVICE AMREX_NO_INLINE
T parser_math_exp (T a) { return std::exp(a); }

template <typename T>
AMREX_GPU_HOST_DEVICE AMREX_NO_INLINE
T parser_math_log (T a) { return std::log(a); }

template <typename T>
AMREX_GPU_HOST_DEVICE AMREX_NO_INLINE
T parser_math_log10 (T a) { return std::log10(a); }

template <typename T>
AMREX_GPU_HOST_DEVICE AMREX_NO_INLINE
T parser_math_sin (T a) { return std::sin(a); }

template <typename T>
AMREX_GPU_HOST_DEVICE AMREX_NO_INLINE
T parser_math_cos (T a) { return std::cos(a); }

template <typename T>
AMREX_GPU_HOST_DEVICE AMREX_NO_INLINE
T parser_math_tan (T a) { return std::tan(a); }

template <typename T>
AMREX_GPU_HOST_DEVICE AMREX_NO_INLINE
T parser_math_asin (T a) { return std::asin(a); }

template <typename T>
AMREX_GPU_HOST_DEVICE AMREX_NO_INLINE
T parser_math_acos (T a) { return std::acos(a); }

template <typename T>
AMREX_GPU_HOST_DEVICE AMREX_NO_INLINE
T parser_math_atan (T a) { return std::atan(a); }

template <typename T>
AMREX_GPU_HOST_DEVICE AMREX_NO_INLINE
T parser_math_sinh (T a) { return std::sinh(a); }

template <typename T>
AMREX_GPU_HOST_DEVICE AMREX_NO_INLINE
T parser_math_cosh (T a) { return std::cosh(a); }

template <typename T>
AMREX_GPU_HOST_DEVICE AMREX_NO_INLINE
T parser_math_tanh (T a) { return std::tanh(a); }

template <typename T>
AMREX_GPU_HOST_DEVICE AMREX_NO_INLINE
T parser_math_comp_ellint_1 (T a)
{
#if defined(__GNUC__) && !defined(__clang__) && !defined(__CUDA_ARCH__)
    return std::comp_ellint_1(a);
#else
    amrex::ignore_unused(a);
    AMREX_ALWAYS_ASSERT_WITH_MESSAGE(false, "parser: comp_ellint_1 only supported with gcc and cpu");
    return 0.0;
#endif
}

template <typename T>
AMREX_GPU_HOST_DEVICE AMREX_NO_INLINE
T parser_math_comp_ellint_2 (T a)
{
#if defined(__GNUC__) && !defined(__clang__) && !defined(__CUDA_ARCH__)
    return std::comp_ellint_2(a);
#else
    amrex::ignore_unused(a);
    AMREX_ALWAYS_ASSERT_WITH_MESSAGE(false, "parser: comp_ellint_2 only supported with gcc and cpu");
    return 0.0;
#endif
}

template <typename T>
AMREX_GPU_HOST_DEVICE AMREX_NO_INLINE
T parser_math_pow (T a, T b) { return std::pow(a,b); }

template <typename T>
AMREX_GPU_HOST_DEVICE AMREX_NO_INLINE
T parser_math_jn (int a, T b)
{
#if defined AMREX_USE_SYCL || defined __MINGW32__
    amrex::ignore_unused(a,b);
    // neither jn(f) nor std::cyl_bessel_j work yet
    // https://github.com/oneapi-src/oneAPI-spec/issues/308
    AMREX_ALWAYS_ASSERT_WITH_MESSAGE(false, "parser: jn in SYCL not supported yet");
    return 0.0;
#else
    return jn(a, b);
#endif
}

AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE double
parser_call_f1 (enum parser_f_t type, double a)
{
    switch (type) {
    case PARSER_F1_NEG:           return -a;
    case PARSER_F1_INV:           return 1.0/a;
    case PARSER_F1_SQRT:          return std::sqrt(a);
    case PARSER_F1_EXP:           return parser_math_exp<double>(a);
    case PARSER_F1_LOG:           return parser_math_log<double>(a);
    case PARSER_F1_LOG10:         return parser_math_log10<double>(a);
    case PARSER_F1_SIN:           return parser_math_sin<double>(a);
    case PARSER_F1_COS:           return parser_math_cos<double>(a);
    case PARSER_F1_TAN:           return parser_math_tan<double>(a);
    case PARSER_F1_ASIN:          return parser_math_asin<double>(a);
    case PARSER_F1_ACOS:          return parser_math_acos<double>(a);
    case PARSER_F1_ATAN:          return parser_math_atan<double>(a);
    case PARSER_F1_SINH:          return parser_math_sinh<double>(a);
    case PARSER_F1_COSH:          return parser_math_cosh<double>(a);
    case PARSER_F1_TANH:          return parser_math_tanh<double>(a);
    case PARSER_F1_ABS:           return std::abs(a);
    case PARSER_F1_FLOOR:         return std::floor(a);
    case PARSER_F1_CEIL:          return std::ceil(a);
    case PARSER_F1_POW_M3:        return 1.0/(a*a*a);
    case PARSER_F1_POW_M2:        return 1.0/(a*a);
    case PARSER_F1_POW_P2:        return a*a;
    case PARSER_F1_POW_P3:        return a*a*a;
    case PARSER_F1_COMP_ELLINT_1: return parser_math_comp_ellint_1<double>(a);
    case PARSER_F1_COMP_ELLINT_2: return parser_math_comp_ellint_2<double>(a);
    default:
        amrex::Abort("parser_call_f1: Unknown function ");
        return 0.0;
    }
}

AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE double
parser_call_f2 (enum parser_f_t type, double a, double b)
{
    switch (type) {
    case PARSER_F2_ADD:       return a+b;
    case PARSER_F2_SUB:       return a-b;
    case PARSER_F2_MUL:       return a*b
    case PARSER_F2_DIV:       return a/b;
    case PARSER_F2_POW:       return parser_math_pow<double>(a,b);
    case PARSER_F2_GT:        return (a > b) ? 1.0 : 0.0;
    case PARSER_F2_LT:        return (a < b) ? 1.0 : 0.0;
    case PARSER_F2_GEQ:       return (a >= b) ? 1.0 : 0.0;
    case PARSER_F2_LEQ:       return (a <= b) ? 1.0 : 0.0;
    case PARSER_F2_EQ:        return (a == b) ? 1.0 : 0.0;
    case PARSER_F2_NEQ:       return (a != b) ? 1.0 : 0.0;
    case PARSER_F2_AND:       return ((a != 0.0) && (b != 0.0)) ? 1.0 : 0.0;
    case PARSER_F2_OR:        return ((a != 0.0) || (b != 0.0)) ? 1.0 : 0.0;
    case PARSER_F2_HEAVISIDE: return (a < 0.0) ? 0.0 : ((a > 0.0) ? 1.0 : b);
    case PARSER_F2_JN:        return parser_math_jn<double>(int(a),b);
    case PARSER_F2_MIN:       return (a < b) ? a : b;
    case PARSER_F2_MAX:       return (a > b) ? a : b;
    case PARSER_F2_FMOD:      return std::fmod(a,b);
    default:
        amrex::Abort("parser_call_f2: Unknown function");
        return 0.0;
    }
}

AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE double
parser_call_f2i (enum parser_f_t type, double a, int b)
{
    switch (type) {
    case PARSER_F2_POW:
    {
#if AMREX_DEVICE_COMPILE || defined(_WIN32)
        return parser_math_pow<double>(a,double(b));
#else
        return __builtin_powi(a,b);
#endif
    }
    default:
        amrex::Abort("parser_call_f2i: Unknown function");
        return 0.0;
    }
}

AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE double
parser_call_f3 (enum parser_f_t /*type*/, double a, double b, double c)
{
    // There is only one type currently
    return (a != 0.0) ? b : c;
}

}

#endif
